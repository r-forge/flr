c //////////////////////////////////////////////////////////////////////
c    UNIT SCR_IO : SCREEN INPUT ROUTINES
c         Three routines to read an integer, a real or a character
c         string from the screen
c         THIS VERSION FOR MS-FORTRAN and FORTRAN dialects
c         that support the line-feed inhibit character  \
c      
c //////////////////////////////////////////////////////////////////////

c      Program Test
      
c      character*60 textin, Valid
c      integer output,max,min
    
c      max=100
c      min = -100

c      textin = 'Choose --> '
c      VAlid = 'aAlLpP'
c      Call SCREEN_IN_I(Textin, Output, Max, Min)
c      write(*,*) output

c      end


c //////////////////////////////////////////////////////////////////////
c
      Subroutine SCREEN_IN_I(Text, Output, Max, Min,Language)
c
c //////////////////////////////////////////////////////////////////////
c     Reads an integer from screen      
c

      character*(*) Text
      character*19 flength
      integer output, Max,Min, length, L1, L2
      character*31 MinErr(4), Maxerr(4)
      integer language

      if (Language .gt. 4) Language = 1
      if (Language .le. 0 ) Language =1 

      MinErr(1)='ERROR: Minimum allowed is : '
      MinErr(2)='ERROR: El m°nimo permitido es :'
      MinErr(3)='ERREUR: Le minimum permis est :'
      MinErr(4)='FEIL: Minimum tillatelig er :'

      MaxErr(1)='ERROR: Maximum allowed is : '
      MaxErr(2)='ERROR: El m†ximo permitido es :'
      MaxErr(3)='ERREUR: Le maximum permis est :'
      MaxErr(4)='FEIL: Maximum tillatelig er :'

      length = LEN(Text)
c
c     count the number of trailing blanks
c
      
      do while (Text(length:length) .eq. ' ')
        length = length-1
      enddo

      length=length+1

c      if (length .ge. 75) then
c        write(*,*) 'Error in routine SCREEN_IN_I: '
c        write(*,*) 'Text string : ',text
c        write(*,*) 'is too long. It should be shorter than 75 chars.'
c        stop
c      endif

      if (Max .le. Min) then
        write(*,*) 'Error in routine SCREEN_IN_I: '
        write(*,*) 'Inconsistent MAX and MIN :',Max, Min
        stop
      endif

      l1 = length/10       ! the tens
      l2 = length-l1*10    ! the units
      

      if (l1 .ne. 0) then
        L1=L1+48
        l2=l2+48

        flength = '('' '',A'//char(L1)//char(L2)//','' --> '',\)'
      else
        l2=l2+48
        flength = '('' '',A'//char(L2)//','' --> '',\)'
      endif


      output = max*2

      do while ((output .gt. max) .or. (output .lt. min))

        write (*,flength) text
        read(*,*) output

        if (output .gt. max) then


          write(*,*) Maxerr(language),max
        else if (output .lt. min) then
          write(*,*) Minerr(language),min
        endif

      enddo

      return
      end ! of routine SCREEN_IN_I
c+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++



c //////////////////////////////////////////////////////////////////////
c
      Subroutine SCREEN_IN_R(Text, Output, Max, Min, Language)
c
c //////////////////////////////////////////////////////////////////////
c     Reads a double-precision real  from screen            
      character*(*) Text
      character*19 flength
      integer  length, L1, L2

      double precision  output, Max,Min


      character*31 MinErr(4), Maxerr(4)
      integer language

      if (Language .gt. 4) Language = 1
      if (Language .le. 0 ) Language =1 

      MinErr(1)='ERROR: Minimum allowed is : '
      MinErr(2)='ERROR: El m°nimo permitido es :'
      MinErr(3)='ERREUR: Le minimum permis est :'
      MinErr(4)='FEIL: Minimum tillatelig er : '

      MaxErr(1)='ERROR: Maximum allowed is : '
      MaxErr(2)='ERROR: El m†ximo permitido es :'
      MaxErr(3)='ERREUR: Le maximum permis est :'
      MaxErr(4)='FEIL: Maximum tillatelig er : '

      length = LEN(Text)
c
c     count the number of trailing blanks
c
      
      do while (Text(length:length) .eq. ' ')
        length = length-1
      enddo

      length=length+1

c      if (length .ge. 75) then
c        write(*,*) 'Error in routine SCREEN_IN_I: '
c        write(*,*) 'Text string : ',text
c        write(*,*) 'is too long. It should be shorter than 75 chars.'
c        stop
c      endif

      if (Max .le. Min) then
        write(*,*) 'Error in routine SCREEN_IN_R: '
        write(*,*) 'Inconsistent MAX and MIN :',Max, Min
        stop
      endif


      l1 = length/10       ! the tens
      l2 = length-l1*10    ! the units
      

      if (l1 .ne. 0) then
        L1=L1+48
        l2=l2+48

        flength = '('' '',A'//char(L1)//char(L2)//','' --> '',\)'
      else
        l2=l2+48
        flength = '('' '',A'//char(L2)//','' --> '',\)'
      endif

      output = max*2d0

      do while ((output .gt. max) .or. (output .lt. min))

        write (*,flength) text
        read(*,*) output

        if (output .gt. max) then
          write(*,*) MAXERR(Language),max
          write(*,*)
        else if (output .lt. min) then
          write(*,*) MinErr(Language),min
          write(*,*)
        endif

      enddo

      return
      end ! of routine SCREEN_IN_I
c+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++




c //////////////////////////////////////////////////////////////////////
c
      Subroutine SCREEN_IN_A(Text, Output, Valid, Language)
c
c //////////////////////////////////////////////////////////////////////
c  
c     Accepts a non-blank character variable from screen
c      Output string is 'Output' 
c      it must be contained within the string 'valid'
c      which holds a list of valid choices
c      

      character*(*) Text
      character*(*) Valid
      character*19 flength
      character*(*) output
      integer  length, L1, L2,  tscan
      character*31 Err(4)
      integer language

      if (Language .gt. 4) Language = 1
      if (Language .le. 0 ) Language =1 

      Err(1)='ERROR: Choose between : '//valid
      Err(2)='ERROR: Elige : '//valid 
      Err(3)='ERREUR: Choissez : '//valid
      Err(4)='FEIL: Valg : '//valid

      
      length = LEN(Text)
c
c     count the number of trailing blanks
c
      
      do while (Text(length:length) .eq. ' ')
        length = length-1
      enddo

      length=length+1

c      if (length .ge. 75) then
c        write(*,*) 'Error in routine SCREEN_IN_I: '
c        write(*,*) 'Text string : ',text
c        write(*,*) 'is too long. It should be shorter than 75 chars.'
c        stop
c      endif

      l1 = length/10       ! the tens
      l2 = length-l1*10    ! the units
      

      if (l1 .ne. 0) then
        L1=L1+48
        l2=l2+48

        flength = '('' '',A'//char(L1)//char(L2)//','' --> '',\)'
      else
        l2=l2+48
        flength = '('' '',A'//char(L2)//','' --> '',\)'
      endif

      output = ' '

      do while ((tscan(output, Valid) .eq. 0).or.(output.eq.' '))

        write (*,flength) text
        read(*,'(A)') output

        if ( tscan(output, Valid) .eq. 0) then
          write(*,*)
          write(*,*) Err(Language)
          write(*,*)
        endif

      enddo

      return
      end ! of routine SCREEN_IN_I
c+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      



C ////////////////////////////////////////////////////////////////////////////////

       Integer Function Tscan( str1, str2 )
       
c ////////////////////////////////////////////////////////////////////////////////       
                                                                                  
c     Returns the position of the first string character that matches a 
c     character in str2, returns zero if there's no match
c            
      character* (*) str1, str2
      integer p,j, out, l1, l2
      l1 = len(str1)         
      l2 = len(str2)
      out =0
      do p=1, l2
        do j= 1, l1
          if (str1(j:j) .eq. str2(p:p)) then
            out =p
            goto 100
          endif
        enddo
      enddo
100   continue
      tscan = out                   
      
      return
      
      end ! of function tscan
                        
c ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++                                                                                       


c///////////////////////////////////////////////////////////////////////

      Subroutine Screen_Out_A(Text, size, lines)

c /////////////////////////////////////////////////////////////////////
c     writes text strings to screen      

      integer size, lines, n
      character*(*) Text(size)

      do n=1, lines
        write(*,*) Text(n)
      enddo
      return
      end

c +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

c ////////////////////////////////////////////////////////////////////////

      SUBROUTINE SCREEN_IN_IR 
     * (TEXT, I1,I2,R, I1Max,I1Min,I2Max,I2Min,RMax,RMin,Language)
c
c /////////////////////////////////////////////////////////////////////////
c
c     Reads two integers and one real, preceded by a request text
c
      implicit none
      character*(*) Text
      character*19 flength
      integer length, I1, I1max, I1Min, I2, I2max, I2Min, l1,l2
      double precision R, Rmax, RMin
      logical error
      character*31 MinErr(4), Maxerr(4)
      integer language

      if (Language .gt. 4) Language = 1
      if (Language .le. 0 ) Language =1 

      MinErr(1)='ERROR: Minimum allowed is : '
      MinErr(2)='ERROR: El m°nimo permitido es : '
      MinErr(3)='ERREUR: Le minimum permis est : '
      MinErr(4)='FEIL: Minimum tillatelig er : '

      MaxErr(1)='ERROR: Maximum allowed is : '
      MaxErr(2)='ERROR: El m†ximo permitido es : '
      MaxErr(3)='ERREUR: Le maximum permis est : '
      MaxErr(4)='FEIL: Maximum tillatelig er : '


      write(*,*)
      length = LEN(Text)
c
c     count the number of trailing blanks
c
      
      do while (Text(length:length) .eq. ' ')
        length = length-1
      enddo

      length=length+1


      l1 = length/10       ! the tens
      l2 = length-l1*10    ! the units
      

      if (l1 .ne. 0) then
        L1=L1+48
        l2=l2+48

        flength = '('' '',A'//char(L1)//char(L2)//','' --> '',\)'
      else
        l2=l2+48
        flength = '('' '',A'//char(L2)//','' --> '',\)'
      endif



      error=.true.
      do while (error)

        write (*,flength) text
        read(*,*) I1,I2,R
        error=.false.
        if (I1 .gt. I1max) then
          write(*,*) Maxerr(Language), I1max,' <  ',I1
          error=.true.
        else if  (I1 .lt. I1min) then
          write(*,*) Minerr(language),I1min, ' > ', I1
          error=.true.
        else if (I2 .gt. I2max) then
          write(*,*) Maxerr(language),I2max,'  < ',I2
          error=.true.
        else if (I2 .lt. I2min) then
          write(*,*) MinErr(language),I2min, ' > ', I2
          error=.true.
        else if  (R .gt. Rmax) then
          write(*,*) Maxerr(language),Rmax,' < ',R
          error=.true.
        else if (R .lt. Rmin) then
          write(*,*) Minerr(language),Rmin, ' > ', R
          error=.true.
        endif

      enddo

      return
      end ! of routine SCREEN_IN_IR
c+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++



c //////////////////////////////////////////////////////////////

      Subroutine IntToChar(INTX,STRING,LENGTH)

c //////////////////////////////////////////////////////////////

          integer intx, length , k, j
          character*(*) string
          character*1 ak(100), blank
          integer tscan

          j=intx
          blank= ' '

          if (intx .lt. 0)then
            write(*,*) 'Error in IntTOChar: -ve argument : ',intx
            stop
          endif

          do k =1,length
            ak(k) = blank
          enddo

          if  (intx .eq. 0) then
            ak(1) = '0'
          else
            do k= DINT(Dlog10(Dble(j)))+1,1,-1
              if ( j .ge. 10**(k-1)) then
                ak(k) = char(48+j/10**(k-1))
                j = j- 10**(k-1)*(j/10**(k-1))
              else
                ak(k) = '0'
              endif
            enddo
          endif

c         concatenate the AK strings without blanks
          
          string = '     '
          do k=length, 1, -1
            if (ak(k) .ne. ' ') then 
              if (String(1:1) .eq. ' ') then
                String(1:1) = ak(k)
              else
                STRING= STRING(1:TSCAN(' ',STRING)-1)//ak(k)
              endif
            endif
c            write(*,*) k, ak(k)
c            write(*,*) 'Substring>',string(1: TSCAN(' ',STRING)),'<'
c            write(*,*) 'string>',string,'<'
c            write(*,*) 'Posn Blank =',Tscan(' ',string)
          enddo

          
          


          return
          end
c +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

c ////////////////////////////////////////////////////////////////////

      Subroutine Screen_in_s(TextIn, TextOut)

c ///////////////////////////////////////////////////////////////////
c
c    writes Textin to the screen, reads TextOut from user
c
      implicit none
      character*19  flength
      character*(*) TextIn, TextOut
      integer length, l1,l2

      write(*,*)
      length = LEN(TextIn)
c
c     count the number of trailing blanks
c
      
      do while (TextIn(length:length) .eq. ' ')
        length = length-1
      enddo

      length=length+1

c      if (length .ge. 75) then
c        write(*,*) 'Error in routine SCREEN_IN_A: '
c        write(*,*) 'Text string : ',textin
c        write(*,*) 'is too long. It should be shorter than 75 chars.'
c        stop
c      endif

      l1 = length/10       ! the tens
      l2 = length-l1*10    ! the units
      

      if (l1 .ne. 0) then
        L1=L1+48
        l2=l2+48

        flength = '('' '',A'//char(L1)//char(L2)//','' --> '',\)'
      else
        l2=l2+48
        flength = '('' '',A'//char(L2)//','' --> '',\)'
      endif

      write (*,flength) textin
      read(*, '(A)') TextOut

      return 
      end ! of routine Screen_in_a

c++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

c ///////////////////////////////////////////////////////////////////////

      Subroutine ConCat(Str1, Str2, Str3)

c ////////////////////////////////////////////////////////////////////////
c
c  trims trailing blanks from string2, adds on string3, retruns string1
c
c
      character*(*) Str1
      character*(*) Str2
      character*(*) Str3
      integer length
      character*1 blank


      length = LEN(STR2)

      do while (STR2(length:length) .eq. ' ')
        length = length-1
      enddo

      length=length+1

      STR1=STR2(1:length)//STR3

      return
      end
c ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


c////////////////////////////////////////////////////////////////////////// 

      Subroutine WinConvert( Text, j,k)

c///////////////////////////////////////////////////////////////////////////
c
c   converts a matrix of <text> from IBM extended-ASCII to 
c    MS-Windows extended character codes.
c    Only 
c
c                                        
       integer j, k
       character*(*) text(j,k)
       integer l, ichange, i1,i2,i3
       character*18 WIN, IBM
       character*500 line
       
       IBM='†ÖÉÇäà¢ìï§á£°Üëîèôí'
       WIN='·‡‚ÈËÍÛÙÚÒÁ˙ÌÂÊ¯≈ÿ∆'

       l=len(Text(1,1))
       if (l .gt. 500) then
         write(*,*) 'ERROR in (SCR_IO) WinConvert: line too lonng'
         stop
       endif

       do i1=1,j
         do i2=1,k
           LINE = text(i1,i2)
           do i3=1,l
             do ichange=1,18
               if (Line(i3:i3) .eq. IBM(ichange:ichange)) 
     *            Line(i3:i3)= WIN(ichange:ichange)
             enddo
           enddo
           text(i1,i2)=line
         enddo
       enddo

       return
       end





